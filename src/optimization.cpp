#include "optimization.hpp"

#include "stack-simulator.hpp"

#include <algorithm>
#include <array>
#include <cassert>
#include <unordered_set>

namespace xrf {

namespace {

/**
 * Attempts to optimize a chunk. This simulates the effect that a given chunk
 * will have on the stack, and based on the end state, it will attempt to
 * generate an optimized sequence of instructions.
 *
 * @param chunk
 *     The XRF chunk to optimize
 * @param index
 *     The index of the chunk in the program
 *
 * @return
 *     The optimized XRF chunk
 */
Chunk optimizeChunk(const Chunk &chunk, unsigned index) {
    StackSimulator stack(index);
    Chunk optimized = chunk;

    bool canOptimize = true;

    for (const auto &cmd: chunk.commands) {
        bool breakOut = false;

        switch (cmd.type) {
            case CommandType::Add:
                stack.add();
                break;

            case CommandType::Bottom:
                stack.bottom();
                break;

            case CommandType::Output:
                stack.output();
                break;

            case CommandType::Pop:
                stack.pop();
                break;

            case CommandType::Dec:
                stack.dec();
                break;

            case CommandType::Dup:
                stack.dup();
                break;

            case CommandType::Inc:
                stack.inc();
                break;

            case CommandType::Input:
                stack.input();
                break;

            case CommandType::Jump:
                breakOut = true;
                break;

            case CommandType::Nop:
                break;

            case CommandType::Sub:
                stack.sub();
                break;

            case CommandType::Swap:
                stack.swap();
                break;

            case CommandType::Exit:
            case CommandType::Randomize:
            case CommandType::IgnoreFirst:
            case CommandType::IgnoreVisited:
                // We don't bother trying to optimize a chunk if any of these
                // commands are in the chunk.
                canOptimize = false;
                break;

            case CommandType::AddToSecond:
            case CommandType::MultiplySecond:
            case CommandType::PopSecondValue:
            case CommandType::PushSecondValue:
            case CommandType::PushValueToBottom:
            case CommandType::SetSecondValue:
            case CommandType::SetTop:
                // These commands are only generated by optimizing a chunk.
                // We will not be able to optimize further than what we've
                // already optimized, so we stop the procedure here.
                canOptimize = false;
                break;
        }

        if (breakOut || !canOptimize) {
            break;
        }
    }

    if (canOptimize) {
        if (auto stackTop = stack.getStackTop(); stackTop) {
            optimized.nextChunk = *stackTop;
        }

        if (auto optimizedCommands = stack.getCommands(); optimizedCommands) {
            optimized.commands = *optimizedCommands;
        }
    }

    return optimized;
}

/**
 * Returns whether a chunk only has the commands in the given array.
 *
 * @tparam N
 *     The size of the array of commands
 * @param chunk
 *     The chunk to check for the commands
 * @param commands
 *     The array containing the list of acceptable command types
 *
 * @return
 *     Returns true if the type of every command in the chunk is in the array
 */
template <size_t N>
bool chunkOnlyHas(const Chunk &chunk, const std::array<CommandType, N> &commands) {
    return std::all_of(chunk.commands.begin(), chunk.commands.end(), [&] (Command cmd) {
        return std::find(commands.begin(), commands.end(), cmd.type) != commands.end();
    });
}

/**
 * Goes through a list of commands, removing all the "Set Stack Top" commands
 * except for the last one.
 *
 * @param commands
 *     The list of commands to remove redundant Set Top commands from
 */
void condenseStackTops(std::vector<Command> &commands) {
    bool foundStackTop = false;

    for (auto it = commands.rbegin(); it != commands.rend(); ++it) {
        if (it->type == CommandType::SetTop) {
            if (foundStackTop) {
                commands.erase(std::next(it).base());
            }
            foundStackTop = true;
        }
    }
}

/**
 * Goes through a list of commands, condensing commands that operate on the
 * second value of the stack. e.g. If there are two commands which multiply
 * the second value by 2, it will combine them into one command to multiply
 * the second value by 4.
 *
 * @param commands
 *     The list of commands to condense
 */
void handleSecondVal(std::vector<Command> &commands) {
    bool pushVal = false;
    std::optional<int> knownVal;
    unsigned multiply = 1;
    int addAmount = 0;

    for (auto it = commands.begin(); it != commands.end(); ) {
        switch (it->type) {
            case CommandType::PushSecondValue:
                pushVal = true;
                knownVal = it->val;
                break;

            case CommandType::SetSecondValue:
                knownVal = it->val;
                break;

            case CommandType::AddToSecond:
                if (knownVal) {
                    *knownVal += it->val;
                }
                else {
                    addAmount += it->val;
                }
                break;

            case CommandType::MultiplySecond:
                if (knownVal) {
                    *knownVal *= it->val;
                }
                else {
                    multiply *= it->val;
                    addAmount *= it->val;
                }
                break;

            default:
                ++it;
                continue;
        }

        it = commands.erase(it);
    }

    if (knownVal) {
        if (pushVal) {
            commands.emplace_back(CommandType::PushSecondValue, *knownVal);
        }
        else {
            commands.emplace_back(CommandType::SetSecondValue, *knownVal);
        }
    }
    else {
        if (multiply > 1) {
            commands.emplace_back(CommandType::MultiplySecond, multiply);
        }
        if (addAmount != 0) {
            commands.emplace_back(CommandType::AddToSecond, addAmount);
        }
    }
}

constexpr auto BEGIN_CHUNK_OPT_COMMANDS = std::array{
    CommandType::AddToSecond,
    CommandType::MultiplySecond,
    CommandType::PushSecondValue,
    CommandType::SetSecondValue,
    CommandType::SetTop,
};

constexpr auto CONTINUE_CHUNK_OPT_COMMANDS = std::array{
    CommandType::AddToSecond,
    CommandType::MultiplySecond,
    CommandType::SetSecondValue,
    CommandType::SetTop,
};

/**
 * Follows the path through the program we will take after a chunk to create a
 * condensed chunk that has the effect that visiting this chunk will have. For
 * instance, if a chunk adds 2 to the second value of the stack, and it takes
 * us to a chunk that adds 2 to the second value of the stack, then this
 * function will produce an optimized chunk that adds 4 to the second value of
 * the stack, and will skip over the second chunk.
 *
 * @param chunks
 *     The list of chunks in the program
 * @param index
 *     The index of the chunk we want to optimize
 *
 * @return
 *     The optimized version of the chunk
 */
Chunk optimizeChunkInProgram(const std::vector<Chunk> &chunks, size_t index) {
    auto &originalChunk = chunks[index];
    Chunk optimizedChunk;

    auto toOptimize = chunks[index];

    std::unordered_set<size_t> visited;

    if (chunkOnlyHas(toOptimize, BEGIN_CHUNK_OPT_COMMANDS)) {
        do
        {
            if (visited.count(index)) {
                // We're in a infinite loop, don't bother optimizing it
                return originalChunk;
            }
            visited.insert(index);

            optimizedChunk.commands.insert(optimizedChunk.commands.end(),
                                           toOptimize.commands.begin(),
                                           toOptimize.commands.end());

            optimizedChunk.nextChunk = toOptimize.nextChunk;
            index = *optimizedChunk.nextChunk;
            toOptimize = chunks[index];
        }
        while (chunkOnlyHas(toOptimize, CONTINUE_CHUNK_OPT_COMMANDS));
    }

    if (optimizedChunk.commands.empty()) {
        return originalChunk;
    }

    condenseStackTops(optimizedChunk.commands);
    handleSecondVal(optimizedChunk.commands);

    return optimizedChunk;
}

} // anonymous namespace

std::vector<Chunk> optimizeChunks(const std::vector<Chunk> &chunks) {
    std::vector<Chunk> optimizedChunks;

    for (size_t i = 0; i < chunks.size(); i++) {
        optimizedChunks.emplace_back(optimizeChunk(chunks[i], i));
    }

    return optimizedChunks;
}

std::vector<Chunk> optimizeProgram(const std::vector<Chunk> &chunks) {
    std::vector<Chunk> optimizedProgram;

    optimizedProgram.reserve(chunks.size());

    for (size_t i = 0; i < chunks.size(); i++) {
        optimizedProgram.emplace_back(optimizeChunkInProgram(chunks, i));
    }

    return optimizedProgram;
}

} // namespace xrf
